<!DOCTYPE html>
<html lang="en">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0">
		<link rel="stylesheet" type="text/css" href="css/core.css" />
		<title>Exploiting DS save games</title>
	</head>
	
	<body>
		<div class="page">
			<div class="container">
				<div class="header">
					<a href="contact.html" class="header-element">
						Contact
					</a>
					
					<a href="skills.html" class="header-element">
						Skills
					</a>
					
					<a href="articles.html" class="header-element">
						Articles
					</a>
					
					<a href="index.html" class="header-element">
						Home
					</a>
				</div>
				
				<h1 id="exploiting-ds-games-through-stack-smashing-vulnerabilities-in-save-files">Exploiting DS games through stack smash vulnerabilities in save files</h1>
				<hr>
				
				<h2 id="introduction">Introduction</h2>
				<p>If you want to learn about hacking, then exploiting DS games though their save files can be a great way to learn the basics.</p>
				<p>DS games operate with very little security in place, if you have some code loaded in memory then you can sometimes just jump straight to it, as opposed to in more modern systems such as the 3DS where there is the <a href="http://en.wikipedia.org/wiki/NX_bit">NX bit</a> (some parts of memory can be marked as unexecutable) and in the PS Vita where there is also <a href="http://en.wikipedia.org/wiki/Address_space_layout_randomization">ASLR</a> (the bases of modules and the stack are randomly arranged).</p>
				<br>
				
				<h2 id="who-is-this-aimed-at">Who is this aimed at?</h2>
				<p>You should have a competent understanding of fairly low level programming. If you don't know what a register is, or the difference between the stack and the heap, then you probably won't get much out of this tutorial.</p>
				<br>
				
				<h2 id="tools-used">Tools used</h2>
				<p>You will need an ARM compiler; I will be using devkitARM from <a href="http://devkitpro.org/">devkitPro</a>.</p>
				<p>You will need a DS emulator; I recommend using <a href="http://desmume.org/">DeSmuME</a> however I have heard that <a href="http://problemkaputt.de/gba.htm">NO$GBA</a> also has excellent debugging tools.</p>
				<p>You will need a hex editor to edit save files; I will be using <a href="http://www.hhdsoftware.com/free-hex-editor">Hex Editor Neo</a>.</p>
				<p>I will also be using <a href="www.cjmweb.net/vbindiff/">VBinDiff</a> which isn't necessary but helps to identify the location of checksums within a save file.</p>
				<br>
				
				<h2 id="what-is-a-buffer-overflow">What is a buffer overflow?</h2>
				<p>There are several different types of buffer overflow, however in this tutorial we will just go over the most common: <a href="http://en.wikipedia.org/wiki/Stack_buffer_overflow">Stack Smashing</a>; overflowing a string on the stack into an address which the Program Counter will read from.</p>
				<p>In order to understand what a Stack Smash is and how it works, you will first need to know a little bit about ARM assembly.</p>
				<p>Both ARM processors on the DS have 16 32 bit registers, the first 13 (R0 to R12) can be used for general purpose calculations, and the last 3 have their own special purposes.</p>
				<p>R13, also referred to as SP, is known as the <a href="http://en.wikipedia.org/wiki/Stack_register">Stack Pointer</a>; it is a pointer to the active <a href="http://en.wikipedia.org/wiki/Stack_%28abstract_data_type%29">stack</a> - a portion of memory where data can be pushed on and off of registers.</p>
				<p>R14, also referred to as LR, is known as the <a href="http://en.wikipedia.org/wiki/Link_register">Link Register</a>; it holds the address to return to after a function call.</p>
				<p>R15, also referred to as PC, is known as the <a href="http://en.wikipedia.org/wiki/Program_counter">Program Counter</a>; it holds the address of the instruction that is currently being executed. In ARM, instructions are 4 bytes long, so once an instruction has been completed the PC will be incremented by 4 in order to point to the next instruction, unless the instruction itself modifies the PC. Also note that sometimes code is executed in <a href="http://en.wikipedia.org/wiki/ARM_architecture#Thumb">Thumb</a> mode which uses 2 bytes per instruction.</p>
				<br>
				
				<h2 id="creating-a-model">Creating a model</h2>
				<p>Let's compile some basic C code to assembly to help us understand how the stack can be modified to control the Program Counter:</p>
				<pre><code>#include &lt;nds.h&gt;
#include &lt;string.h&gt;

void copy(void) {
	char buffer[8];
	memset(buffer, 0xAA, 8);
}

void turnScreenRed(void) {
	REG_DISPCNT = MODE_0_2D;
	VRAM_A_CR = VRAM_ENABLE | VRAM_A_MAIN_BG;
	BG_PALETTE[0] = RGB15(31, 0, 0);
}

int main(void) {
	copy();
	
	turnScreenRed();
	
	while(1);
	
	return 0;
}
</code></pre>
				<p>We will use this Makefile to generate assembly from the above C:</p>
				<pre><code>include $(DEVKITARM)/ds_rules

CFLAGS := -I$(LIBNDS)/include -DARM9 -O1 -march=armv5te -mtune=arm946e-s -nodefaultlibs -nostartfiles

main.s: main.c
	$(CC) main.c $(CFLAGS) -S</code></pre>
				<p>Once we remove some of the clutter from the generated assembly we will be left with this:</p>
				<pre><code>    .text
	
	.align    2
	.global    copy
	.type    copy, %function
copy:
	@ args = 0, pretend = 0, frame = 8
	@ frame_needed = 0, uses_anonymous_args = 0
	str    lr, [sp, #-4]!
	sub    sp, sp, #12
	mov    r0, sp
	mov    r1, #170
	mov    r2, #8
	bl    memset
	add    sp, sp, #12
	@ sp needed
	ldr    pc, [sp], #4
	
	.align    2
	.global    turnScreenRed
	.type    turnScreenRed, %function
turnScreenRed:
	@ args = 0, pretend = 0, frame = 0
	@ frame_needed = 0, uses_anonymous_args = 0
	@ link register save eliminated.
	mov    r2, #65536
	mov    r3, #67108864
	str    r2, [r3]
	mvn    r2, #126
	add    r3, r3, #512
	strb    r2, [r3, #64]
	mov    r2, #31
	mov    r3, #83886080
	strh    r2, [r3]    @ movhi
	bx    lr
	
	.align    2
	.global    main
	.type    main, %function
main:
	@ Volatile: function does not return.
	@ args = 0, pretend = 0, frame = 0
	@ frame_needed = 0, uses_anonymous_args = 0
	stmfd    sp!, {r3, lr}
	bl    copy
	bl    turnScreenRed</code></pre>
				<p>Let's ignore the first instruction in <code>main</code> for now and just see how <code>copy</code> is called:</p>
				<pre><code>bl    copy</code></pre>
				<p>This is the <a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0489e/Cihfddaf.html">Branch with Link</a> instruction, it puts the address of the instruction after it (PC + 4) into the Link Register, and then jumps to the copy function by setting the PC to the address of it. The address in the Link Register is needed because after the function we called has completed, we want the program to resume executing from the next instruction after <code>bl copy</code>.</p>
				<p>Now let's look at the <code>copy</code> function, here's the first instruction:</p>
				<pre><code>str    lr, [sp, #-4]!</code></pre>
				<p>This stores the Link Register at the address that the Stack Pointer holds minus 4 bytes. The reason this happens is so that other instructions (such as <code>bl memset</code>) can modify the Link Register, and then at the end of the function we can restore the value back from the stack. Again, this value tells us where to return to after the function has completed.</p>
				<p>At the end of the function, the address is loaded into the PC, which takes us to the instruction after the <code>bl copy</code>.</p>
				<pre><code>ldr    pc, [sp], #4</code></pre>
				<p>Now that you understand how our <code>copy</code> function is called, we can run through the whole program.</p>
				<p>To start with, let's just assume that our stack is empty:</p>
				<pre><code>Stack Pointer -&gt;</code></pre>
				<p>The first instruction in <code>main</code> is:</p>
				<pre><code>stmfd    sp!, {r3, lr}</code></pre>
				<p>This is the <a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0068b/Cacbgchh.html">Store Multiple Full Descending</a> instruction. It pushes Register 3 and the Link Register onto the stack at the address stored by the Stack Pointer.</p>
				<p>Just as with the <code>copy</code> function, the Link Register is needed on the stack so that code in the body of the function can modify it freely, and then at the end of the function it can be restored so that we can return to the next instruction.</p>
				<p>The reason that Register 3 is also pushed onto the stack is to <a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.faqs/ka4127.html">keep the stack aligned to 8 bytes for function calls</a>.</p>
				<p>At this point the stack will look like this:</p>
				<pre><code>Stack Pointer -&gt; R3 (4 bytes)
                 LR (4 bytes)</code></pre>
				<p>Then there is a Branch with Link to our <code>copy</code> function:</p>
				<pre><code>bl    copy</code></pre>
				<p>So the next instruction will be the one at the start of <code>copy</code>:</p>
				<pre><code>str    lr, [sp, #-4]!</code></pre>
				<p>As explained earlier, this will push the Link Register onto the stack; which will now look like this:</p>
				<pre><code>Stack Pointer -&gt; LR (4 bytes)
                 R3 (4 bytes)
                 LR (4 bytes)</code></pre>
				<p>The next instruction moves the Stack Pointer up by 12 bytes to reserve space for our buffer.</p>
				<pre><code>sub    sp, sp, #12</code></pre>
				<p>The reason that 12 bytes are reserved instead of just the 8 that we need, is to keep the stack 8 byte aligned for function calls (as mentioned earlier).</p>
				<p>The stack will now look like this:</p>
				<pre><code>Stack Pointer -&gt; Buffer (8 bytes)
                 Padding (4 bytes)
                 LR (4 bytes)
                 R3 (4 bytes)
                 LR (4 bytes)</code></pre>
				<p>The next group of instructions just call <code>memset</code>:</p>
				<pre><code>mov    r0, sp
mov    r1, #170
mov    r2, #8
bl     memset</code></pre>
				<p>Parameters for functions are usually stored in Register 0 and onwards. For our <code>memset</code> call the destination is the Stack Pointer (which currently points to our buffer), the value is <code>0xAA</code>, and the length is <code>8 bytes</code>.</p>
				<p>This is safe because it only modifies the 8 bytes that we reserved for our buffer.</p>
				<p>The Stack Pointer is then moved down 12 bytes:</p>
				<pre><code>add    sp, sp, #12</code></pre>
				<p>So that it looks the same as it was before we reserved space for the buffer:</p>
				<pre><code>Stack Pointer -&gt; LR (4 bytes)
                 R3 (4 bytes)
                 LR (4 bytes)</code></pre>
				<p>And finally it will take the Link Register that was saved onto the Stack, and load it into the PC:</p>
				<pre><code>ldr    pc, [sp], #4</code></pre>
				<p>If we run this program in DeSmuME, we can verify that the code reaches the <code>turnScreenRed</code> function as intended because the screen turns red.</p>
				<p>Let's modify the <code>memset</code> call to get it to write further down the stack than the buffer:</p>
				<pre><code>memset(buffer, 0xAA, 8 + 4 + 4);</code></pre>
				<p>If we go back to the stack diagram we will see that the memory that our program expects to be the Link Register will be overflowed into:</p>
				<pre><code>Stack Pointer -&gt; Buffer (8 bytes)
                 Padding (4 bytes)
                 LR (4 bytes)
                 R3 (4 bytes)
                 LR (4 bytes)</code></pre>
				<p>So that the stack will contain this data:</p>
				<pre><code>Stack Pointer -&gt; 8 bytes of 0xAA
                 4 bytes of 0xAA
                 4 bytes of 0xAA
                 R3 (4 bytes)
                 LR (4 bytes)</code></pre>
				<p>The Stack Pointer will then be moved down by 12 bytes:</p>
				<pre><code>add    sp, sp, #12</code></pre>
				<p>Giving us this stack:</p>
				<pre><code>Stack Pointer -&gt; 4 bytes of 0xAA
                 R3 (4 bytes)
                 LR (4 bytes)</code></pre>
				<p>So now, when the program reaches this instruction:</p>
				<pre><code>ldr    pc, [sp], #4</code></pre>
				<p>Our PC will load the value <code>0xAAAAAAAA</code> off of the stack, where it will continue executing code from.</p>
				<p>Let's verify this by loading our ROM into DeSmuME and opening the Disassembler:</p>
				<p><img src="images/DARA/Exploit.png" /></p>
				<p>Sure enough, instead of returning to the <code>bl turnScreenRed</code> instruction like it did before, it returned to our <code>0xAAAAAAAA</code> address and continued executing code from there!</p>
				<p>In a real exploit, we will have the code we want to run loaded somewhere in memory, which we will make the PC jump to instead of the arbitrary <code>0xAAAAAAAA</code>.</p>
				<p>We can now apply this knowledge to a real game exploit!</p>
				<br>
				
				<h2 id="choosing-a-target">Choosing a target</h2>
				<p>All games have a chance of being exploitable, not just low budget indie games, so don't be put off of trying a game just because it <a href="http://wiibrew.org/wiki/Twilight_Hack">appears to be well made on the surface</a>.</p>
				<p>For a basic buffer overflow, a good thing to try to exploit is the player name since it's easy to locate in a save file and is often loaded multiple times in a game.</p>
				<p>For other ideas <a href="http://dsibrew.org/wiki/DSiWare_VulnList">here</a>'s an interesting list which shows you the kind of things that people try to exploit.</p>
				<p>If you don't want to spend time searching for an exploitable game then here's a hint for you: <a href="https://github.com/CTurt/Dara">all FIFA games on the DS are exploitable</a>.</p>
				<p>For this tutorial I will be exploiting the game FIFA 09 (E) DS.</p>
				<br>
				
				<h2 id="checksums">Checksums</h2>
				<p>Before we can start modifying save files we will need to get one other thing out of the way, <a href="http://en.wikipedia.org/wiki/Checksum">checksums</a>.</p>
				<p>A checksum is a representation of a piece of data that is used to make sure that the data is not corrupt.</p>
				<p>If we just modify a save file without correcting the necessary checksums, and load it into the game, it will be detected as corrupt, and will be deleted.</p>
				<p>Usually, DS games use simple functions which we can work out without having to disassemble the ROM.</p>
				<p>First of all, we will need to dump some save files which are slightly different in order to locate where the checksum is.</p>
				<p>I created two different save files in FIFA 09, one with the profile name entered as &quot;AAAAAAAAAA&quot;, and the other with the name &quot;AAAAAAAAAB&quot; leaving everything else as default. In DeSmuME, go to File -&gt; Export Backup Memory to write these saves to files.</p>
				<p>Let's analyse the two files with VBinDiff:</p>
				<p><img src="images/DARA/VBinDiff.png" /></p>
				<p>We can clearly see that the checksum for this game is 2 bytes long and is located at 0x04 in the save file.</p>
				<p>So now we can write a program which reads the checksum from a save file and prints it to the screen, in C this would look like this:</p>
				<pre><code>#include &lt;stdio.h&gt;

int main(int argc, char **argv) {
	if(argc &lt; 2) {
		printf(&quot;FIFA 09 DS (E) save checksum fixer\n&quot;);
		printf(&quot;Usage:\n&quot;);
		printf(&quot;checksumFix [save1.sav] [save2.sav] ...\n&quot;);
		return 1;
	}
	
	int i;
	for(i = 1; i &lt; argc; i++) {
		FILE *f = fopen(argv[i], &quot;rwb+&quot;);
		
		if(!f) {
			printf(&quot;Failed to open\n&quot;);
			fclose(f);
			return 1;
		}
		
		unsigned short checksum;
		fseek(f, 0x0000004, SEEK_SET);
		fread(&amp;checksum, sizeof(unsigned short), 1, f);
		
		fclose(f);
		
		printf(&quot;%s:\n&quot;, argv[i]);
		printf(&quot;%p\n&quot;, checksum);
	}
	
	return 0;
}
</code></pre>
				<p>Compiling, and running this program with AAAAAAAAAA.sav gives the following output:</p>
				<pre><code>gcc main.c -O2 -o checksumFix.exe
checksumFix AAAAAAAAAA.sav
AAAAAAAAAA.sav:
0000F58C</code></pre>
				<p>Now let's redirect <code>stdout</code> to a file and run checksumFix on all of the save files at once to get a list like this:</p>
				<pre><code>AAAAAAAAAA.sav:
0000F58C
AAAAAAAAAB.sav:
0000F62F
AAAAAAAAAC.sav:
0000F6D2
AAAAAAAABA.sav:
0000F630
AAAAAAABAA.sav:
0000F631
AAAAAABAAA.sav:
0000F632
AAAAABAAAA.sav:
0000F633
BAAAAAAAAA.sav:
0000F638
CTurt.sav:
00009675</code></pre>
				<p>The more data you have, the easier it will be to work out how the checksums are generated.</p>
				<p>Basically what we want to do now is work out the difference between these checksums in order to see how 1 byte changes the resultant checksum.</p>
				<p>We start by seeing how the final byte of the profile name (located at <code>0x69</code> in the save) affects the checksum, we will work out the difference between AAAAAAAAAB.sav and AAAAAAAAAA.sav:</p>
				<pre><code>0x0000F62F - 0x0000F58C = 0xA3</code></pre>
				<p>To verify that this is always the case, we will also compare AAAAAAAAAC.sav with AAAAAAAAAB.sav:</p>
				<pre><code>0x0000F6D2 - 0x0000F62F = 0xA3</code></pre>
				<p>Great! We can now confirm that the byte at <code>0x69</code> changes the checksum by <code>0xA3</code>. Using this information we can predict that the checksum of AAAAAAAAAD would be <code>AAAAAAAAAC + 0xA3 = 0x0000F775</code>.</p>
				<p>If we do the same process on the byte at <code>0x68</code> (<code>AAAAAAAABA - AAAAAAAAAA</code>) we will discover that this byte alters the checksum by <code>0xA4</code>.</p>
				<p>And the byte at <code>0x67</code> alters the checksum by <code>0xA5</code>. Can you spot the pattern yet?</p>
				<p>Using this knowledge we can write our first attempt at calculating the checksum. We will just use the bytes from <code>0x0020</code> to <code>0x010C</code> because anything further down in the save uses a different checksum which we don't want to deal with right now:</p>
				<pre><code>unsigned short fifa09echecksum(unsigned char *data) {
	unsigned short checksum = 0;
	
	int i;
	for(i = 0x00000020; i &lt; 0x0000010C; i++) {
		checksum += (data[i] * ((0xA3 + 0x69) - i));
	}
	
	return checksum;
}</code></pre>
				<p>Let's try it out! Running AAAAAAAAAA.sav through our application generates <code>0xF579</code>, however the real checksum is <code>0xF58C</code>. There is a simple solution to this, work out the difference between your generated checksum and the real checksum and use it as the initial checksum:</p>
				<pre><code>0xF58C - 0xF579 = 0x13</code></pre>
				<p>After some cleaning up, our final function will look like this:</p>
				<pre><code>unsigned short fifa09echecksum(unsigned char *data) {
	unsigned short checksum = 0x13;
	
	int i;
	for(i = 0x00000020; i &lt; 0x0000010C; i++) {
		checksum += data[i] * (0x0000010C - i);
	}
	
	return checksum;
}</code></pre>
				<p>Our application can now generate checksums which correctly match those already found in the saves!</p>
				<p>Another way to do this, which might be easier for you, is to locate the position of the checksum in RAM and set a breakpoint on it. When the emulator compares the checksum it has calculated with the checksum at this location the breakpoint will be triggered; now you can trace backwards in the disassembly until you find the computation code.</p>
				<p>With the checksum out of the way, it's time to try modifying the save file and looking for crashes!</p>
				<br>
				
				<h2 id="initial-overflow-attempt">Initial overflow attempt</h2>
				<p>In FIFA 09 the maximum length for a profile name is 10 bytes (followed by a byte of 0x00 to signify the end of the name), let's try using a longer name:</p>
				<p><img src="images/DARA/Overflow.png" /></p>
				<p>Correct the checksum and then import the save file into DeSmuME (make sure to select the correct size).</p>
				<p>After going to My FIFA 09 -&gt; My Profile we are greeted with this:</p>
				<p><img src="images/DARA/Crash.png" /></p>
				<p>Look familiar? Our profile name overflowed the stack into an address which the PC read from, we have a stack smash!</p>
				<br>
				
				<h2 id="refining-the-overflow">Refining the overflow</h2>
				<p>We know that the PC is only 4 bytes long, so not all of these <code>0xAA</code>s are necessary, keep removing them until the game stops jumping to <code>0xAAAAAAAA</code> to find the exact location.</p>
				<p>We now have complete control over the PC.</p>
				<p><img src="images/DARA/Refined.png" /></p>
				<br>
				
				<h2 id="finding-the-jump-address">Finding the jump address</h2>
				<p>Launch the crash, and then go to Tools -&gt; View Memory -&gt; Dump All. This will dump the memory of ARM 9 at the time of the crash.</p>
				<p>Open this with a hex editor and search for something in your save file, like the profile name.</p>
				<p>Find an appropriate location which you can load your payload at (must be aligned to 4 bytes):</p>
				<p><img src="images/DARA/Dump.png" /></p>
				<p>In the case of FIFA 09, the location in the file is <code>0x0028af40</code>, you need to add <code>0x02000000</code> to this value to get the real address, <code>0x0228af40</code>.</p>
				<p>Replace the <code>0xAAAAAAAA</code> in your save file with the real return address, remember that the DS is Little Endian, so the individual bytes of <code>0x0228af40</code> are <code>40 af 28 02</code>.</p>
				<br>
				
				<h2 id="injecting-a-payload">Injecting a payload</h2>
				<p>Let's compile a very small payload that makes the bottom screen flash different colours:</p>
				<pre><code>#define MODE_FB0 0x00020000
#define VRAM_ENABLE 0x80
#define VRAM_A_LCD 0
#define VRAM_A 0x06800000

.global _start
_start:
mov r0, #0x04000000                     @ I/O space offset
mov r1, #0x3                            @ Both screens on

mov r2, #MODE_FB0                       @ Use VRAM_A as framebuffer
mov r3, #(VRAM_ENABLE | VRAM_A_LCD)     @ VRAM bank A enabled in LCD mode
mov r4, #0                              @ Full brightness (FIFA Street 2 fades out before our code)

str r1, [r0, #0x304]                    @ Set POWERCNT
str r2, [r0]                            @        DISPCNT
str r3, [r0, #0x240]                    @        VRAMCNT_A
str r4, [r0, #0x6C]                     @        MASTER BRIGHT

reset:
add r1, #31                             @ Next colour
mov r0, #VRAM_A                         @ VRAM A offset, framebuffer
mov r2, #(256 * 192)                    @ Pixel count

writePixel:
strh r1, [r0], #2                       @ Write a pixel
subs r2, r2, #1                         @ Move along one
bne writePixel                          @ Fill whole screen

b reset</code></pre>
				<p>We will use this <code>Makefile</code>:</p>
				<pre><code>include $(DEVKITARM)/ds_rules

payload.bin: arm9.s
	$(CC) -nostartfiles -nostdlib -x assembler-with-cpp arm9.s -Ttext=0x0228af40 -o payload.elf
	$(OBJCOPY) -O binary payload.elf $@
	@rm -f payload.elf</code></pre>
				<p>Here's what our compiled payload looks like:</p>
				<p><img src="images/DARA/Payload.png" /></p>
				<p>For this payload it is unnecessary, but you will need to compile with <code>-Ttext=(your return address)</code> if you want to be able to access memory relative to where the payload is loaded.</p>
				<p>With this injected so that the code will be loaded at your return address, and the checksum corrected, you will have your completed save file:</p>
				<p><img src="images/DARA/Final.png" /></p>
				<p>If you import this save file and trigger the exploit you should hopefully see your payload running!</p>
				<p><img src="images/DARA/Hacked.png" /></p>
				<p>If it just crashes, or does nothing, then:</p>
				<ul>
					<li>Check that your payload is loaded in memory where you think it is,</li>
					<li>Check that the PC is going where you want it to,</li>
				</ul>
				<p>The above screenshot shows you how to do both of these things in DeSmuME.</p>
				<br>
				
				<h2 id="tips">Tips</h2>
				<p>If you're using NO$GBA, you can place this instruction at the start of your payload:</p>
				<pre><code>mov r11, r11</code></pre>
				<p>to trigger a breakpoint:</p>
				<p><img src="images/DARA/NO$GBA.png" /></p>
				
				<br>
				
				<p>If you cannot predict exactly where your payload will be loaded in RAM, then you can start it with a list of <code>NOP</code>s, like so:</p>
				<pre><code>    .global _start
_start:
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	
	@ Real code starts here</code></pre>
				<p><a href="http://en.wikipedia.org/wiki/NOP"><code>NOP</code></a> (short for No Operation) does nothing, and just causes the Program Counter to advance to the next instruction. This means that you don't have to get the address of the first instruction absolutely perfect; as long as you jump somewhere within the NOP slide, all of your real code will still be executed.</p>
				<br>
				
				<h2 id="testing-on-real-hardware">Testing on real hardware</h2>
				<p>The most convenient way is just to use a flashcard. If you want to transfer your save file to a real cartridge you can use <a href="http://filetrip.net/file.php?id=2433">NDS Backup Tool WiFi</a> or a hardware solution such as NDS Adaptor Plus.</p>
				<br>
				
				<h2 id="where-to-go-from-here">Where to go from here</h2>
				<p>There are many creative ways that you can try to exploit something, from <a href="http://smealum.net/ninjhax/">QR codes</a> to <a href="https://www.youtube.com/watch?v=zEd4Vw2bmBE">sound</a>. In general, if a program accepts input, there's a chance that you can exploit it! You can also try different systems, such as the <a href="http://wololo.net/2009/03/11/finding-gamesaves-exploits-on-the-psp/">PSP</a> which, like the DS, doesn't use the NX bit or ASLR.</p>
			</div>
		</div>
	</body>
</html>
