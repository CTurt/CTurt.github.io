<!DOCTYPE html>
<html lang="en">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0">
		<link rel="stylesheet" type="text/css" href="css/core.css" />
		<title>PS4</title>
	</head>
	
	<body>
		<div class="page">
			<div class="container">
				<div class="header">
					<a href="skills.html" class="header-element">
						Skills
					</a>
					
					<a href="articles.html" class="header-element">
						Articles
					</a>
					
					<a href="ds.html" class="header-element">
						DS
					</a>
					
					<a href="index.html" class="header-element">
						Home
					</a>
				</div>
				
				<h1>Analysis of PS4's security and the state of hacking</h1>
				<hr>
				
				<p>
					Since there haven't been any major public announcements regarding PS4 hacking for a long time now, I wanted to explain a bit about how far PS4 hacking has come, and what is preventing further progression.
				</p>
				
				<p>
					I will explain some security concepts that generally apply to all modern systems, and my discoveries that I made from running tests on the PS4.
				</p>
				
				<p>
					If you are not particularly familiar with exploitation, you should read my article about <a href="DS-exploit-finding.html">exploiting DS games through stack smash vulnerabilities in save files</a> first.
				</p>
				
				<br>
				
				<h2>Background information about the PS4</h2>
				<div class="quote">
					As you probably know the PS4 features a custom AMD x86-64 CPU (8 cores), and there are loads of research available for this CPU architecture, even if this specific version might deviate slightly from known standards. For example, PFLA (Page Fault Liberation Army) released a proof of concept implementing a complete Turing machine using only page faults and the x86 MMU during the 29C3 congress, check their awesome video over at YouTube. Also interesting if you are trying to run code within a virtual machine and want to execute instructions on the host CPU.
				</div>
				
				<div class="quote-reference">
					- <a href="http://www.eurasia.nu/modules.php?name=News&file=article&sid=3251&mode=&order=0&thold=0">EurAsia news article 3251</a>
				</div>
				<br>
				
				<br>
				
				<p>
					As well as having a well documented CPU architecture, much of <a href="https://en.wikipedia.org/wiki/PlayStation_4_system_software">the software used in the PS4</a> is <a href="http://www.scei.co.jp/ps4-license/">open source</a>.
				</p>
				
				<p>
					Most notably, the PS4's Orbis OS is based on FreeBSD, just like the PS3's OS was (with parts of NetBSD as well); but as well as FreeBSD 9.0, other noticable software used includes <a href="http://www.mono-project.com/docs/advanced/runtime/">Mono VM</a>, and <a href="https://www.webkit.org/">WebKit</a>.
				</p>
				
				<br>
				
				<h2>WebKit entry point</h2>
				<p>
					WebKit is the open source layout engine which renders web pages in the browsers for iOS, Wii U, 3DS, PS Vita, and the PS4.
				</p>
				
				<p>
					Although so widely used and mature, WebKit does have its share of vulnerabilities; you can learn about most of them by reading <a href="https://en.wikipedia.org/wiki/Pwn2Own#Summary_of_successful_exploits">Pwn2Own write-ups</a>.
				</p>
				
				<p>
					In particular, the browser in PS4 firmware 1.76 uses a version of WebKit which is vulnerable to <a href="https://www.exploit-db.com/exploits/28081/">CVE-2012-3748</a>, a heap-based buffer overflow in the <code>JSArray::sort(...)</code> method.
				</p>
				
				<p>
					In 2014, nas and Proxima announced that they had successfully been able to <a href="http://wololo.net/talk/viewtopic.php?p=368577">port this exploit to the PS4's browser</a>, and released the PoC code publicly as the first entry point into hacking the PS4.
				</p>
				
				<p>
					This gives us arbitrary read and write access to everything the WebKit process can read and write to, which can be used to dump modules, and overwrite return addresses on the stack, letting us control the Program Counter (for ROP).
				</p>
				
				<p>
					Since then, many <a href="http://wololo.net/2015/04/22/new-webkit-exploit-found-vita-maybe-playstation-4/">other vulnerabilities have been found in WebKit</a>, which could probably allow for module dumping and ROP on later firmwares of the PS4, but as of writing, no one has ported any of these exploits to the PS4 publicly.
				</p>
				
				<br>
				
				<h2>What is ROP?</h2>
				<p>
					Unlike in primitive devices like the <a href="exploits.html">DS</a> and PSP, the PS4 has a kernel which controls the properties of different areas of memory. Pages of memory which are marked as executable cannot be overwritten, and pages of memory which are marked as writable cannot be executed; this is known as <a href="https://en.wikipedia.org/wiki/Data_Execution_Prevention">Data Execution Prevention (DEP)</a>.
				</p>
				
				<p>
					This means that we can't just copy a payload into memory and execute it. However, we can execute code which is already loaded into memory and marked as executable.
				</p>
				
				<p>
					<a href="https://en.wikipedia.org/wiki/Return-oriented_programming">Return-Oriented Programming (ROP)</a> is just an extension to traditional stack smashing, but instead of overwriting only a single value which the PC will jump to, we can chain together many different addresses, known as gadgets.
				</p>
				
				<p>
					A gadget is usually just a single desired instruction followed by a <code>ret</code>.
				</p>
				
				<p>
					In x86_64 assembly, when a <code>ret</code> instruction is reached, a 64bit value is popped off the stack and the PC jumps to it; since we can control the stack, we can make every <code>ret</code> instruction jump to the next desired gadget.
				</p>
				
				<p>
					For example, from <code>0x80000</code> may contains instructions:
				</p>
				
				<pre><code>mov rax, 0
ret</code></pre>
				
				<p>
					And from <code>0x90000</code> may contain instructions:
				</p>
				
				<pre><code>mov rbx, 0
ret</code></pre>
				
				<p>
					If we overwrite a return address on the stack to contain <code>0x80000</code> followed by <code>0x90000</code>, then as soon as the first <code>ret</code> instruction is reached execution will jump to <code>mov rax, 0</code>, and immediately afterwards, the next <code>ret</code> instruction will pop <code>0x90000</code> off the stack and jump to <code>mov rbx, 0</code>.
				</p>
				
				<p>
					Effectively this chain will set both <code>rax</code> and <code>rbx</code> to 0, just as if we had written the code into a single location and executed it from there.
				</p>
				
				<p>
					ROP chains aren't limited to just a list of addresses; assuming that from <code>0xa0000</code> contains these instructions:
				</p>
				
				<pre><code>pop rax
ret</code></pre>
				
				<p>
					We can set the first item in the chain to <code>0xa0000</code> and the next item to any desired value for <code>rax</code>. This means that with sufficient gadgets, ROP can do basically anything.
				</p>
				
				<br>
				
				<h2>Finding gadgets</h2>
				<p>
					Think of ROP as writing a new chapter to a book, using only words that have appeared at the end of sentences in the previous chapters.
				</p>
				
				<p>
					It's obvious from the structure of most sentences that we probably won't be able to find words like 'and' or 'but' appearing at the end of any sentences, but we will need these connectives in order to write anything meaningful.
				</p>
				
				<p>
					It is quite possible however, that a sentence has ended with 'sand'. Although the author only ever intended for the word to be read from the 's', if we start reading from the 'a', it will appear as an entirely different word by coincidence, 'and'.
				</p>
				
				<p>
					These principles also apply to ROP.
				</p>
				
				<p>
					Since the structure of almost all functions follows something like this:
				</p>
				
				<pre><code>; Save registers
push    rbp
mov     rbp, rsp
push    r15
push    r14
push    r13
push    r12
push    rbx
sub     rsp, 18h

; Function body

; Restore registers
add     rsp, 18h
pop     rbx
pop     r12
pop     r13
pop     r14
pop     r15
pop     rbp
ret</code></pre>
				
				<p>
					You'd expect to only be able to find <code>pop</code> gadgets, or more rarely, something like <code>xor rax, rax</code> to set the return value to 0 before returning.
				</p>
				
				<p>
					Having a comparison like:
				</p>
				
				<pre><code>cmp [rax], r12
ret</code></pre>
				
				<p>
					Wouldn't make any sense since the result of the comparison isn't used by the function. However, there is still a possibility that we can find gadgets like these.
				</p>
				
				<p>
					Luckily for us, x86_64 instructions have variable lengths, just like words. And also like words, x86_64 instructions can mean something entirely different if decoded from an unintended location.
				</p>
				
				<div class="quote">
					The x86_64 architecture is a variable-length CISC instruction set. Return-oriented programming on the x86_64 takes advantage of the fact that the instruction set is very "dense", that is, any random sequence of bytes is likely to be interpretable as some valid set of x86_64 instructions.
				</div>
				
				<div class="quote-reference">
					- <a href="https://en.wikipedia.org/wiki/Return-oriented_programming">Wikipedia</a>
				</div>
				<br>
				
				<br>
				
				<p>
					To demonstrate this, take a look at the end of this function from the WebKit module:
				</p>
				
				<pre><code>000000000052BE0D                 mov     eax, [rdx+8]
000000000052BE10                 mov     [rsi+10h], eax
000000000052BE13                 or      byte ptr [rsi+39h], 20h
000000000052BE17                 ret</code></pre>
				
				<p>
					Now take a look at what the code looks like if we start decoding from 0x52be14:
				</p>
				
				<pre><code>000000000052BE14                 cmp     [rax], r12
000000000052BE17                 ret</code></pre>
				
				<p>
					Even though this code was never intended to be executed, it is within an area of memory which has been marked as executable, so it is perfectly valid to use as a gadget.
				</p>
				
				<p>
					Of course, it would be incredibily time consuming to look at every possible way of interpreting code before every single <code>ret</code> instruction manually; and that's why tools exist to do this for you. The one that I use to search for ROP gadgets is <a href="https://github.com/0vercl0k/rp/">rp++</a>; to generate a text file filled with gadgets, just use:
				</p>
				
				<pre><code>rp-win-x64 -f mod14.bin --raw=x64 --rop=1 --unique > mod14.txt</code></pre>
				
				<p>
					It is generally accepted that within a sufficiently large enough code dump, there will be enough gadgets for <a href="https://en.wikipedia.org/wiki/Turing_completeness">Turing-complete</a> functionality. So ROP is a viable method of bypassing DEP which will still let us execute almost anything we want.
				</p>
				
				<br>
				
				<h2>Segmentation faults</h2>
				<p>
					If we <i>do</i> try to execute a non-executable page of memory, or try to write to a non-writable page of memory, a <a href="https://en.wikipedia.org/wiki/Segmentation_fault">segmentation fault</a> will occur.
				</p>
				
				<p>
					For example, trying to execute code on the stack, which is mapped as read and write only:
				</p>
				
				<pre><code>setU8to(stack_base + return_va + 0x480 + 0, 0xeb);
setU8to(stack_base + return_va + 0x480 + 1, 0xfe);

chain.add(stack_base + return_va + 0x480);</code></pre>
				
				<p>
					And trying to write to code, which is mapped as read and execute only:
				</p>
				
				<pre><code>setU8to(wk_base, 0);</code></pre>
				
				<p>
					If a segmentation fault occurs, a message saying "There is not enough free system memory" will appear, and the page will fail to load:
				</p>
				
				<div class="center">
					<img src="images/PS4/segfault.png" />
				</div>
				
				<br>
				
				<p>
					There are other possible reasons for this message to be displayed, such as executing an invalid instruction or an unimplemented system call, but a segmentation fault is the most common.
				</p>
				
				<br>
				
				<h2>ASLR</h2>
				<p>
					<a href="https://en.wikipedia.org/wiki/Address_space_layout_randomization">Address Space Layout Randomization (ASLR)</a> is a security technique which causes the base addresses of modules to be different every time you start the PS4.
				</p>
				
				<p>
					It has been reported to me that <a href="https://www.youtube.com/watch?v=aEu208625XA">very old firmwares (1.05) don't have ASLR enabled</a>, but it was introduced sometime before firmware 1.70. Note that kernel ASLR is not enabled (for firmwares 1.76 and lower at least), which will be proved later in the article.
				</p>
				
				<p>
					For most exploits ASLR would be a problem because if you don't know the addresses of the gadgets in memory, you would have no idea what to write to the stack.
				</p>
				
				<p>
					Luckily for us, if we read the modules table with JavaScript to get the base addresses of all loaded modules, we can calculate the addresses of our gadgets before we trigger ROP execution, bypassing ASLR.
				</p>
				
				<p>
					The modules table also includes the filenames of the modules:
				</p>
				
				<ul>
					<li>libkernel.sprx</li>
					<li>libSceLibcInternal.sprx</li>
					<li>libSceSysmodule.sprx</li>
					<li>libSceNet.sprx</li>
					<li>libSceNetCtl.sprx</li>
					<li>libSceIpmi.sprx</li>
					<li>libSceMbus.sprx</li>
					<li>libSceRegMgr.sprx</li>
					<li>libSceRtc.sprx</li>
					<li>libScePad.sprx</li>
					<li>libSceVideoOut.sprx</li>
					<li>libScePigletv2VSH.sprx</li>
					<li>libSceOrbisCompat.sprx</li>
					<li>libSceWebKit2.sprx</li>
					<li>libSceSysCore.sprx</li>
					<li>libSceSsl.sprx</li>
					<li>libSceVideoCoreServerInterface.sprx</li>
					<li>libSceSystemService.sprx</li>
					<li>libSceCompositeExt.sprx</li>
				</ul>
				
				<p>
					Although the PS4 predominantly uses the [<b>S</b>igned] <b>P</b>PU <b>R</b>elocatable E<b>x</b>ecutable ([S]PRX) format for modules, some string references to [<b>S</b>igned] <b>E</b>xecutable and <b>L</b>inking <b>F</b>ormat ([S]ELF) object files can also be found in the <code>libSceSysmodule.sprx</code> dump, such as <code>bdj.elf</code>, <code>web_core.elf</code> and <code>orbis-jsc-compiler.self</code>. This combination of modules and objects is similar to what is used in the PSP and PS3.
				</p>
				
				<p>
					You can view <a href="http://www.psdevwiki.com/ps4/Libraries">a complete list of all modules available</a> (not just those loaded by the browser) in <code>libSceSysmodule.sprx</code>. We can load and dump some of these through several of Sony's custom system calls, which will be explained later in this article.
				</p>
				
				<br>
				
				<h2>JuSt-ROP</h2>
				<p>
					Using JavaScript to write and execute dynamic ROP chains gives us a tremendous advantage over a standard buffer overflow attack.
				</p>
				
				<p>
					As well as bypassing ASLR, we can also read the user agent of the browser, and provide a different ROP chain for different browser versions, giving our exploit the highest compatibility possible.
				</p>
				
				<p>
					We can even use JavaScript to read the memory at our gadgets' addresses to check that they are correct, giving us almost perfect reliability.
				</p>
				
				<p>
					Writing ROP chains dynamically, rather than generating them with a script beforehand, just makes sense.
				</p>
				
				<p>
					I created a JavaScript framework for writing ROP chains, <a href="https://github.com/CTurt/JuSt-ROP">JuSt-ROP</a>, for this very reason.
				</p>
				
				<br>
				
				<h2>JavaScript caveats</h2>
				<p>
					JavaScript represents numbers using the <a href="https://en.wikipedia.org/wiki/IEEE_floating_point">IEEE-754</a> double-precision (64bit) format. This provides us with 53bit precision, meaning that it isn't possible to represent every 64bit value, approximations will have to be used for some.
				</p>
				
				<p>
					If you just need to set a 64bit value to something low, like <code>256</code>, then <code>setU64to</code> will be fine.
				</p>
				
				<p>
					But for situations in which you need to write a buffer or struct of data, there is the possibility that certain bytes will be written incorrectly if it has been written in 64bit chunks.
				</p>
				
				<p>
					Instead, you should write data in 32bit chunks (remembering that the PS4 is little endian), to ensure that every byte is exact.
				</p>
				
				<br>
				
				<h2>System calls</h2>
				<p>
					Interestingly, the PS4 uses the same <a href="https://www.freebsd.org/doc/en/books/developers-handbook/x86-system-calls.html#x86-alternate-calling-convention">calling convention as Linux and MS-DOS for system calls</a>, with arguments stored in registers, rather than the traditional UNIX way (which FreeBSD uses by default), with arguments stored in the stack:
				</p>
				
				<ul>
					<li><code>rax</code> - System call number</li>
					<li><code>rdi</code> - Argument 1</li>
					<li><code>rsi</code> - Argument 2</li>
					<li><code>rdx</code> - Argument 3</li>
					<li><code>rcx</code> - Argument 4</li>
					<li><code>r8</code> - Argument 5</li>
					<li><code>r9</code> - Argument 6</li>
				</ul>
				
				<p>
					We can try to perform any system call with the following JuSt-ROP method:
				</p>
				
				<pre><code>this.syscall = function(name, systemCallNumber, arg1, arg2, arg3, arg4, arg5, arg6) {
	console.log("syscall " + name);
	
	this.add("pop rax", systemCallNumber);
	if(typeof(arg1) !== "undefined") this.add("pop rdi", arg1);
	if(typeof(arg2) !== "undefined") this.add("pop rsi", arg2);
	if(typeof(arg3) !== "undefined") this.add("pop rdx", arg3);
	if(typeof(arg4) !== "undefined") this.add("pop rcx", arg4);
	if(typeof(arg5) !== "undefined") this.add("pop r8", arg5);
	if(typeof(arg6) !== "undefined") this.add("pop r9", arg6);
	this.add("pop rbp", stackBase + returnAddress - (chainLength + 8) + 0x1480);
	this.add("mov r10, rcx and syscall");
}</code></pre>
				
				<p>
					Using system calls can tell us a huge amount about the PS4 kernel. Not only that, but using system calls is most likely the only way that we can interact with the kernel, and thus potentially trigger a kernel exploit.
				</p>
				
				<p>
					If you are reverse engineering modules to identify some of Sony's custom system calls, you may be confused by the calling convention which Sony uses.
				</p>
				
				<p>
					Sony performs all system calls through regular system call 0 (which usually does nothing in FreeBSD), with the first argument (<code>rdi</code>) controlling the system call to be executed. So the calling convention Sony uses for system calls is as follows:
				</p>
				
				<ul>
					<li><code>rax</code> - 0</li>
					<li><code>rdi</code> - System call number</li>
					<li><code>rsi</code> - Argument 1</li>
					<li><code>rdx</code> - Argument 2</li>
					<li><code>rcx</code> - Argument 3</li>
					<li><code>r8</code> - Argument 4</li>
					<li><code>r9</code> - Argument 5</li>
				</ul>
				
				<p>
					It is unclear why Sony does this, but either convention will work:
				</p>
				
				<pre><code>// Both will get the current process ID:
chain.syscall("getpid", 20);
chain.syscall("getpid", 0, 20);</code></pre>
				
				<p>
					The option to use different registers can be extremely handy in ROP where we have a limited amount of gadgets.
				</p>
				
				<br>
				
				<h2>getpid</h2>
				<p>
					Just by using system call 20, <a href="http://www.freebsd.org/cgi/man.cgi?query=getpid&sektion=2">getpid(void)</a>, we can learn a lot about the kernel.
				</p>
				
				<p>
					The very fact that this system call works at all tells us that Sony didn't bother mixing up the system call numbers as a means of <a href="https://en.wikipedia.org/wiki/Security_through_obscurity">security through obscurity</a> (under the BSD license they could have done this without releasing the new system call numbers).
				</p>
				
				<p>
					So, we automatically have a <a href="http://fxr.watson.org/fxr/source/kern/syscalls.master">list of system calls in the PS4 kernel</a> to try.
				</p>
				
				<p>
					Secondly, by calling <code>getpid()</code>, restarting the browser, and calling it again, we get a return value 1 higher than the previous value. Although FreeBSD has supported <a href="http://security.stackexchange.com/questions/88692/do-randomized-pid-bring-more-security">PID randomisation</a> since 4.0, sequential PID allocation is the default behaviour.
				</p>
				
				<p>
					The fact that PID allocation is set to the default behaviour indicates that Sony likely didn't bother adding any additional security enhancements such as those encouraged by projects like <a href="https://hardenedbsd.org/">HardenedBSD</a>.
				</p>
				
				<br>
				
				<h2>Dumping additional modules</h2>
				<p>
					We can dump additional modules by following these stages:
				</p>
				
				<ul>
					<li>Load the module</li>
					<li>Get the module's base address</li>
					<li>Dump the module</li>
				</ul>
				
				<p>
					I tediously tried loading and dumping every single module from within the Internet Browser manually, and posted the results on <a href="http://www.psdevwiki.com/ps4/Libraries#Libraries_on_firmware_1.76">psdevwiki</a>. All modules with <i>Yes</i> next to them can be dumped with this method.
				</p>
				
				<p>
					To load a module we will need to use the <code>sceSysmoduleLoadModule</code> function from <code>libSceSysmodule.sprx + 0x1850</code>. The first parameter is the module ID to load, and the other 3 should just be passed 0.
				</p>
				
				<p>
					The following JuSt-ROP method can be used to perform a function call:
				</p>
				
				<pre><code>this.call = function(name, module, address, arg1, arg2, arg3, arg4, arg5, arg6) {
	console.log("call " + name);
	
	if(typeof(arg1) !== "undefined") this.add("pop rdi", arg1);
	if(typeof(arg2) !== "undefined") this.add("pop rsi", arg2);
	if(typeof(arg3) !== "undefined") this.add("pop rdx", arg3);
	if(typeof(arg4) !== "undefined") this.add("pop rcx", arg4);
	if(typeof(arg5) !== "undefined") this.add("pop r8", arg5);
	if(typeof(arg6) !== "undefined") this.add("pop r9", arg6);
	this.add("pop rbp", stack_base + return_va - (chainLength + 8) + 0x1480);
	this.add(module_bases[module] + address);
}</code></pre>
				
				<p>
					So, to load module <code>0xb</code>:
				</p>
				
				<pre><code>chain.call("sceSysmoduleLoadModule", libSysmodule, 0x1850, 0xb, 0, 0, 0);</code></pre>
				
				<p>
					This should return <code>0</code> on success. To confirm that the module was loaded correctly, we can use one of Sony's custom system calls, number <code>592</code>, to read get a list of currently loaded modules:
				</p>
				
				<pre><code>var data = stack_base + return_va + 0x480;
var countAddress = data;
var modulesAddress = data + 8;

// System call 592, sceGetLoadedModules(int *moduleIDs, int max, int *count);
// returns 0 on success
chain.syscall("sceGetLoadedModules", 592, modulesAddress, 256, countAddress);

var count = getU64from(countAddress);
for(var index = 0; index &lt; count; index++) {
	logAdd("Module: 0x" + getU32from(modulesAddress + index * 4).toString(16));
}</code></pre>
				
				<p>
					Running this without loading any additional modules will produce the following list:
				</p>
				
				<pre><code>0x0, 0x1, 0x2, 0xc, 0xe, 0xf, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1e, 0x37, 0x59</code></pre>
				
				<p>
					But if we run it after loading module <code>0xb</code>, we seen an additional entry, <code>0x65</code>. Note that module ID is <i>not</i> the same as loaded module ID.
				</p>
				
				<p>
					We can now use another of Sony's custom system calls, number <code>593</code>, which takes a loaded module ID and a buffer, and fills the buffer with information about the loaded module, including its base address. Since the loaded module ID is always <code>0x65</code>, we can hardcode it into our chain, rather than having to store the result from the module list.
				</p>
				
				<p>
					The buffer must start with the size of the struct that should be returned, otherwise error <code>0x16</code> will be returned, <code>"Invalid argument"</code>:
				</p>
				
				<pre><code>setU64to(moduleInfoAddress, 0x160);
chain.syscall("sceKernelGetModuleInfo", 593, 0x65, moduleInfoAddress);
logAdd(hexDump(moduleInfoAddress, 0x160));</code></pre>
				
				<p>
					It will return <code>0</code> upon success, and fill the buffer with a struct which can be read like so:
				</p>
				
				<pre><code>var name = readString(moduleInfoAddress + 0x8);
var codeBase = getU64from(moduleInfoAddress + 0x108);
var codeSize = getU32from(moduleInfoAddress + 0x110);
var dataBase = getU64from(moduleInfoAddress + 0x118);
var dataSize = getU32from(moduleInfoAddress + 0x120);</code></pre>
				
				<p>
					We now have everything we need to dump the module!
				</p>
				
				<pre><code>doDump(codeBase, ((codeSize + dataSize) / 0x1000), 0x1000);</code></pre>
				
				<p>
					Since the dumping code that came with the original PoC has a tendency crash the browser halfway through. You should replace the loop starting from:
				</p>
				
				<pre><code>for(var bb=0;bb&lt;maxiters;bb++) {</code></pre>
				
				<p>
					With this:
				</p>
				
				<pre><code>function du(bb) {
	var dump_data = "";
	
	for(var aa=0; aa &lt; (maxsize-1); aa++) {
		dump_data += u32[(bb*maxsize)+aa].toString(16) +",";
	}
	
	dump_data += u32[(maxsize-1)].toString(16);
	
	fname = "dump.php?name=dump-0x" + xx.toString(16) + "-" + bb;
	$.ajax({
		async : false,
		url : fname,
		type: "POST",
		data : dump_data,
		success: function(data, textStatus, jqXHR) {
			logAdd("upload: success");
			
			if(bb &lt; maxiters) {
				bb++;
				du(bb);
			}
		},
		error: function (jqXHR, textStatus, errorThrown) {
			logAdd("upload fail: " + textStatus);
		}
	});
}

du(0);</code></pre>
				
				<p>
					There is another Sony system call, number <code>608</code>, which works in a similar way to <code>593</code>, but provides slightly different information about the module:
				</p>
				
				<pre><code>setU64to(moduleInfoAddress, 0x1a8);
chain.syscall("sceKernelGetModuleInfo2", 608, 0x65, 0, moduleInfoAddress);
logAdd(hexDump(moduleInfoAddress, 0x1a8));</code></pre>
				
				<br>
				
				<h2>How many custom system calls are there?</h2>
				<p>
					The <a href="http://fxr.watson.org/fxr/source/kern/syscalls.master#L988">last standard FreeBSD system call</a> is <code>utimensat</code>, number <code>547</code>; anything higher than this must be a custom Sony system call.
				</p>
				
				<p>
					Invoking any of Sony's custom system calls without the correct arguments will return error <code>0x16</code>, <code>"Invalid argument"</code>. Any compatibility or unimplemented system calls will report the "There is not enough free system memory" error.
				</p>
				
				<p>
					Through trial and error, I have found that system call number <code>617</code> is the last Sony system call, anything higher is unimplemented.
				</p>
				
				<p>
					From this, we can conclude that there are 70 custom Sony system calls in the PS4's kernel (617 - 547).
				</p>
				
				<p>
					This is significantly less than the PS3, which had <a href="http://www.ps3devwiki.com/ps3/LV2_Functions_and_Syscalls">almost 1000 system calls</a> in total. This indicates that we have fewer possible attack vectors, but that it may be easier to document all of the system calls.
				</p>
				
				<p>
					Furthermore, since I haven't tried all of them, I can't confirm that they are all accessible to us; some may only be callable from development units for example.
				</p>
				
				<br>
				
				<h2>Browsing the filesystem</h2>
				<p>
					We can use the <code>open</code> and <code>read</code> system calls on the <code>/dev/</code> directory to list everything it contains:
				</p>
				
				<pre><code>writeString(stack_base + return_va + 0x480, "/dev/");
chain.syscall("open", 5, stack_base + return_va + 0x480, 0, 0);
chain.write_rax_ToVariable(0);

chain.read_rdi_FromVariable(0);
chain.syscall("read", 3, undefined, stack_base + return_va + 0x480 + 0x10, 1028);</code></pre>
				
				<p>
					This is the resultant memory:
				</p>
				
				<pre><code>0000010: 0700 0000 1000 0205 6469 7073 7700 0000  ........dipsw...
0000020: 0800 0000 1000 0204 6e75 6c6c 0000 0000  ........null....
0000030: 0900 0000 1000 0204 7a65 726f 0000 0000  ........zero....
0000040: 0301 0000 0c00 0402 6664 0000 0b00 0000  ........fd......
0000050: 1000 0a05 7374 6469 6e00 0000 0d00 0000  ....stdin.......
0000060: 1000 0a06 7374 646f 7574 0000 0f00 0000  ....stdout......
0000070: 1000 0a06 7374 6465 7272 0000 1000 0000  ....stderr......
0000080: 1000 0205 646d 656d 3000 0000 1100 0000  ....dmem0.......
0000090: 1000 0205 646d 656d 3100 0000 1300 0000  ....dmem1.......
00000a0: 1000 0206 7261 6e64 6f6d 0000 1400 0000  ....random......
00000b0: 1000 0a07 7572 616e 646f 6d00 1600 0000  ....urandom.....
00000c0: 1400 020b 6465 6369 5f73 7464 6f75 7400  ....deci_stdout.
00000d0: 1700 0000 1400 020b 6465 6369 5f73 7464  ........deci_std
00000e0: 6572 7200 1800 0000 1400 0209 6465 6369  err.........deci
00000f0: 5f74 7479 3200 0000 1900 0000 1400 0209  _tty2...........
0000100: 6465 6369 5f74 7479 3300 0000 1a00 0000  deci_tty3.......
0000110: 1400 0209 6465 6369 5f74 7479 3400 0000  ....deci_tty4...
0000120: 1b00 0000 1400 0209 6465 6369 5f74 7479  ........deci_tty
0000130: 3500 0000 1c00 0000 1400 0209 6465 6369  5...........deci
0000140: 5f74 7479 3600 0000 1d00 0000 1400 0209  _tty6...........
0000150: 6465 6369 5f74 7479 3700 0000 1e00 0000  deci_tty7.......
0000160: 1400 020a 6465 6369 5f74 7479 6130 0000  ....deci_ttya0..
0000170: 1f00 0000 1400 020a 6465 6369 5f74 7479  ........deci_tty
0000180: 6230 0000 2000 0000 1400 020a 6465 6369  b0.. .......deci
0000190: 5f74 7479 6330 0000 2200 0000 1400 020a  _ttyc0..".......
00001a0: 6465 6369 5f73 7464 696e 0000 2300 0000  deci_stdin..#...
00001b0: 0c00 0203 6270 6600 2400 0000 1000 0a04  ....bpf.$.......
00001c0: 6270 6630 0000 0000 2900 0000 0c00 0203  bpf0....).......
00001d0: 6869 6400 2c00 0000 1400 0208 7363 655f  hid.,.......sce_
00001e0: 7a6c 6962 0000 0000 2e00 0000 1000 0204  zlib............
00001f0: 6374 7479 0000 0000 3400 0000 0c00 0202  ctty....4.......
0000200: 6763 0000 3900 0000 0c00 0203 6463 6500  gc..9.......dce.
0000210: 3a00 0000 1000 0205 6462 6767 6300 0000  :.......dbggc...
0000220: 3e00 0000 0c00 0203 616a 6d00 4100 0000  >.......ajm.A...
0000230: 0c00 0203 7576 6400 4200 0000 0c00 0203  ....uvd.B.......
0000240: 7663 6500 4500 0000 1800 020d 6e6f 7469  vce.E.......noti
0000250: 6669 6361 7469 6f6e 3000 0000 4600 0000  fication0...F...
0000260: 1800 020d 6e6f 7469 6669 6361 7469 6f6e  ....notification
0000270: 3100 0000 5000 0000 1000 0206 7573 6263  1...P.......usbc
0000280: 746c 0000 5600 0000 1000 0206 6361 6d65  tl..V.......came
0000290: 7261 0000 8500 0000 0c00 0203 726e 6700  ra..........rng.
00002a0: 0701 0000 0c00 0403 7573 6200 c900 0000  ........usb.....
00002b0: 1000 0a07 7567 656e 302e 3400 0000 0000  ....ugen0.4.....
00002c0: 0000 0000 0000 0000 0000 0000 0000 0000  ................</code></pre>
				
				<p>
					You can change the <code>writeString</code> call to read some of the devices listed, for example: reading <code>/dev/urandom</code> will fill the memory with random data.
				</p>
				
				<p>
					Unfortunately, I was unable to read any directories other than <code>/dev/</code> due to sandboxing. Trying to read files and directories that <a href="http://www.psdevwiki.com/ps4/Talk:Files_on_the_PS4">do exist</a> but are restricted will give you error 2, <code>ENOENT</code>, <code>"No such file or directory"</code>.
				</p>
				
				<br>
				
				<h2>Sandboxing</h2>
				<p>
					As well as file related system calls failing for certain paths, there are other reasons for a system call to fail.
				</p>
				
				<p>
					Most commonly, a disallowed system call will just return error <code>1</code>, <code>EPERM</code>, <code>"Operation not permitted"</code>; such as trying to use <code>ptrace</code>, but other system calls may fail for different reasons:
				</p>
				
				<p>
					Compatibilty system calls are disabled. If you are trying to call <code>mmap</code> for example, you must use <a href="http://fxr.watson.org/fxr/source/kern/syscalls.master#L854">system call number 447</a>, not <a href="http://fxr.watson.org/fxr/source/kern/syscalls.master#L172">71</a> or <a href="http://fxr.watson.org/fxr/source/kern/syscalls.master#L379">197</a>; otherwise a segfault will be triggered.
				</p>
				
				<p>
					Other system calls such as <code>exit</code> will also trigger a segmentation fault:
				</p>
				
				<pre><code>chain.syscall("exit", 1, 0);</code></pre>
				
				<p>
					Trying to create an SCTP socket will return error <code>0x2b</code>, <code>EPROTONOSUPPORT</code>, indicating that SCTP sockets have been disabled in the PS4 kernel:
				</p>
				
				<pre><code>//int socket(int domain, int type, int protocol);
//socket(AF_INET, SOCK_STREAM, IPPROTO_SCTP);
chain.syscall("socket", 97, 2, 1, 132);</code></pre>
				
				<p>
					And although calling <code>mmap</code> with <code>PROT_READ | PROT_WRITE | PROT_EXEC</code> will return a valid pointer, the memory still isn't actually executable and will trigger a segfault if you try:
				</p>
				
				<pre><code>chain.syscall("mmap", 477, 0, 4096, 1 | 2 | 4, 4096, -1, 0);
chain.write_rax_ToVariable(0);
chain.read_rdi_FromVariable(0);
chain.add("pop rax", 0xfeeb);
chain.add("mov [rdi], rax");
chain.add("mov rax, rdi");
chain.add("jmp rax");</code></pre>
				
				<p>
					The list of <a href="http://www.scei.co.jp/ps4-license/">open source software used in the PS4</a> doesn't list any kind of sandboxing software like <a href="https://www.freebsd.org/cgi/man.cgi?query=capsicum">Capsicum</a>, so this means that the PS4 must use either pure <a href="https://www.freebsd.org/doc/handbook/jails.html">FreeBSD jails</a>, or some kind of custom, proprietary, sandboxing system (unlikely).
				</p>
				
				<br>
				
				<h2>Jails</h2>
				<p>
					We can prove the existence of FreeBSD jails being actively used in the PS4's kernel through the <code>auditon</code> system call being impossible to execute within a jailed environment:
				</p>
				
				<pre><code>chain.syscall("auditon", 446, 0, 0, 0);</code></pre>
				
				<p>
					The first thing the <code>auditon</code> system call does is check <code>jailed</code> <a href="https://github.com/freebsd/freebsd/blob/054f9cab595b222f85a975c8e12658ce0856c346/sys/security/audit/audit_syscalls.c#L165">here</a>, and if so, return <code>ENOSYS</code>:
				</p>
				
				<pre><code>if (jailed(td->td_ucred))
	return (ENOSYS);</code></pre>
				
				<p>
					Otherwise the system call would most likely return <code>EPERM</code> from the <code>mac_system_check_auditon</code> <a href="https://github.com/freebsd/freebsd/blob/054f9cab595b222f85a975c8e12658ce0856c346/sys/security/audit/audit_syscalls.c#L169">here</a>:
				</p>
				
				<pre><code>error = mac_system_check_auditon(td->td_ucred, uap->cmd);
if (error)
	return (error);</code></pre>
				
				<p>
					Or from the <code>priv_check</code> <a href="https://github.com/freebsd/freebsd/blob/054f9cab595b222f85a975c8e12658ce0856c346/sys/security/audit/audit_syscalls.c#L174">here</a>:
				</p>
				
				<pre><code>error = priv_check(td, PRIV_AUDIT_CONTROL);
if (error)
	return (error);</code></pre>
				
				<p>
					The absolute furthest that the system call could reach would be immediately after the <code>priv_check</code>, <a href="https://github.com/freebsd/freebsd/blob/054f9cab595b222f85a975c8e12658ce0856c346/sys/security/audit/audit_syscalls.c#L178">here</a>, before returning <code>EINVAL</code> due to the length argument being 0:
				</p>
				
				<pre><code>if ((uap->length <= 0) || (uap->length > sizeof(union auditon_udata)))
	return (EINVAL);</code></pre>
				
				<p>
					Since <code>mac_system_check_auditon</code> and <code>priv_check</code> will never return <code>ENOSYS</code>, having the <code>jailed</code> check pass is the only way <code>ENOSYS</code> could be returned.
				</p>
				
				<p>
					When executing the chain, <code>ENOSYS</code> <i>is</i> returned (<code>0x48</code>).
				</p>
				
				<p>
					This tells us that whatever sandbox system the PS4 uses is at least based on jails because <code>jailed</code> <a href="https://github.com/freebsd/freebsd/blob/054f9cab595b222f85a975c8e12658ce0856c346/sys/kern/kern_jail.c#L3518">returns 1</a> when called by the kernel.
				</p>
				
				<br>
				
				<h2>FreeBSD 9.0 kernel exploits</h2>
				<p>
					It makes little sense trying to look for new kernel vulnerabilities in the <a href="https://github.com/freebsd/freebsd/tree/master/sys/kern">FreeBSD kernel source code</a> because since <a href="https://www.freebsd.org/releases/9.0R/schedule.html">FreeBSD 9.0's release on 12'th January 2012</a>, <a href="https://www.exploit-db.com/platform/?p=freebsd">several kernel exploits have already been found</a>, which the PS4 could potentially be vulnerable to.
				</p>
				
				<p>
					We can immediately dismiss some of these for obvious reasons:
				</p>
				
				<ul>
					<li>
						<a href="https://www.exploit-db.com/exploits/26368/">FreeBSD 9.0-9.1 mmap/ptrace - Privilege Escalation Exploit</a> - this won't work since, as previously stated, we don't have access to the <code>ptrace</code> system call.
					</li>
					
					<li>
						<a href="https://www.exploit-db.com/exploits/28718/">FreeBSD 9.0 - Intel SYSRET Kernel Privilege Escalation Exploit</a> - won't work because the PS4 uses an AMD processor.
					</li>
					
					<li>
						<a href="https://www.exploit-db.com/exploits/35938/">FreeBSD Kernel - Multiple Vulnerabilities</a> - maybe the first vulnerability will lead to something, but the other 2 rely on SCTP sockets, which the PS4 kernel has disabled (as previously stated).
					</li>
				</ul>
				
				<p>
					However, there are <a href="http://www.cvedetails.com/vulnerability-list/vendor_id-6/product_id-7/version_id-118765/Freebsd-Freebsd-9.0.html">some smaller vulnerabilites</a>, which could lead to something:
				</p>
				
				<br>
				
				<h2>getlogin</h2>
				<p>
					One vulnerability which looks easy to try is using the <a href="http://www.cvedetails.com/cve/CVE-2014-8476/">getlogin system call to leak a small amount of kernel memory</a>.
				</p>
				
				<p>
					The <a href="https://www.freebsd.org/cgi/man.cgi?query=getlogin&sektion=2"><code>getlogin</code></a> system call is intended to copy the login name of the current session to userland memory, however, due to a bug, the whole buffer is always copied, and not just the size of the name string. This means that we can read some uninitialised data from the kernel, which might be of some use.
				</p>
				
				<p>
					Note that the system call (49) is actually <code>int getlogin_r(char *name, int	len);</code> and not <code>char *getlogin(void);</code>.
				</p>
				
				<p>
					So, let's try copying some kernel memory into an unused part of userland memory:
				</p>
				
				<pre><code>chain.syscall("getlogin", 49, stack_base + return_va + 0x480, 17);</code></pre>
				
				<p>
					Unfortunately 17 bytes is the most data we can get, since:
				</p>
				
				<div class="quote">
					Login names are limited to <code>MAXLOGNAME</code> (from <code>&lt;sys/param.h&gt;</code>) characters, currently 17 including null.
				</div>
				
				<div class="quote-reference">
					- <a href="https://www.freebsd.org/cgi/man.cgi?query=getlogin&sektion=2">FreeBSD Man Pages</a>
				</div>
				<br>
				
				<br>
				
				<p>
					After executing the chain, the return value was 0, which means that the system call worked! An excellent start. Now let's take a look at the memory which we pointed to:
				</p>
				
				<p>
					Before executing the chain:
				</p>
				
				<pre><code>00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00</code></pre>
				
				<p>
					After executing the chain:
				</p>
				
				<pre><code>72 6f 6f 74 00 fe ff ff 08 62 61 82 ff ff ff ff
00</code></pre>
				
				<p>
					After decoding the first 4 bytes as ASCII:
				</p>
				
				<pre><code>root</code></pre>
				
				<p>
					So the browser is executed as root! That was unexpected.
				</p>
				
				<p>
					But more interestingly, the memory leaked looks like a pointer to something in the kernel, which is always the same each time the chain is run; this is evidence to support <a href="https://twitter.com/yifanlu/status/551498289284009984">Yifanlu's claims that the PS4 has no Kernel ASLR</a>!
				</p>
				
				<br>
				
				<h2>Summary</h2>
				<p>
					From the information currently available, the PS4's kernel seems to be very similar to the stock FreeBSD 9.0 kernel.
				</p>
				
				<p>
					Importantly, the differences that <i>are</i> present appear to be from standard <a href="https://www.freebsd.org/doc/handbook/kernelconfig-custom-kernel.html">kernel configuration</a> changes (such as disabling SCTP sockets), rather than from modified code. Sony have also added several of their own custom system calls to the kernel, but apart from this, the rest of the kernel seems fairly untouched.
				</p>
				
				<p>
					In this respect, I'm inclined to believe that the PS4 shares most of the same juicy vulnerabilities as FreeBSD 9.0's kernel!
				</p>
				
				<p>
					Unfortunately, most kernel exploits cannot be triggered from the WebKit entry point that we currently have due to sandboxing constraints (likely to be just stock FreeBSD jails).
				</p>
				
				<p>
					And with FreeBSD 10 being out, it's unlikely that anyone is stashing away any private exploits for FreeBSD 9, so unless a new one is suddenly released, we're stuck with what is currently available.
				</p>
				
				<p>
					It may not be impossible to exploit the PS4 kernel by leveraging some of the existing kernel memory corruption vulnerabilities, but it certainly would't be easy.
				</p>
				
				<p>
					The best approach from here seems to be reverse engineering all of the modules which can be dumped, in order to document as many of Sony's custom system calls as possible; I have a hunch that we will have more luck targeting these, than the standard FreeBSD system calls.
				</p>
				
				<p>
					Recently <a href="http://hackinformer.com/2015/06/24/breaking-news-discovered-two-communication-ports-uart-playstation-4/">Jaicrab has discovered two UART ports on the PS4</a> which shows us that there are hardware hackers interested in the PS4. Although the role of hardware hackers has traditionally been to dump the RAM of a system, <a href="http://farm4.static.flickr.com/3441/3869187499_da1665050d.jpg">like with the DSi</a>, which we can already do thanks to the WebKit exploit, there's also the possibility of a hardware triggered kernel vulnerability being found, like <a href="http://rdist.root.org/2010/01/27/how-the-ps3-hypervisor-was-hacked/">geohot's original PS3 hypervisor hack</a>. It remains most likely that a kernel exploit will be found on the PS4 through system call vulnerabilities though.
				</p>
				
				<br>
				
				<h2>Thanks</h2>
				<ul>
					<li>nas</li>
					<li>Proxima</li>
					<li>Takezo</li>
					<li>Hunger</li>
					<li>Xerpi</li>
					<li>droogie</li>
					<li>SKFU</li>
				</ul>
			</div>
		</div>
	</body>
</html>
